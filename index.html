<!DOCTYPE html>
<html>
<head>
    <title>Glowdrop Catcher Evolved</title>
    <style>
        /* Basic reset and full window setup */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            height: 100%;
            background-color: #1a1a3a; /* Background for areas outside canvas (if any) */
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            color: white;
        }
        canvas {
            display: block; /* Removes bottom space under canvas */
            width: 100vw; /* Make canvas fill viewport width */
            height: 100vh; /* Make canvas fill viewport height */
            background-color: #2a2a5a; /* Canvas background color */
            cursor: none; /* Hide the default mouse cursor */
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 28px;
            z-index: 10;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.7);
            pointer-events: none; /* Prevent score from interfering with canvas clicks if needed */
        }
    </style>
</head>
<body>

<div id="info">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('info');

    // --- Screen and Resize Handling ---
    let SCREEN_WIDTH = window.innerWidth;
    let SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH; // Set initial render size
    canvas.height = SCREEN_HEIGHT;

    function handleResize() {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        canvas.width = SCREEN_WIDTH;
        canvas.height = SCREEN_HEIGHT;

        // Re-initialize elements dependent on screen size
        initializeStars(); // Regenerate stars for new size

        // Clamp catcher position to new bounds
        catcherX = Math.max(0, Math.min(SCREEN_WIDTH, catcherX));
        catcherY = Math.max(0, Math.min(SCREEN_HEIGHT, catcherY));
        mouseX = catcherX;
        mouseY = catcherY;

        console.log(`Resized to ${SCREEN_WIDTH}x${SCREEN_HEIGHT}`);
    }
    window.addEventListener('resize', handleResize);


    // --- Game Constants & Initial Values ---
    const GLOWDROP_RADIUS = 14;
    const GLOWDROP_SPEED_MIN = 1.2;
    const GLOWDROP_SPEED_MAX = 3.5;
    const GLOWDROP_SPAWN_INTERVAL = 800;
    const MAX_GLOWDROPS = 25;
    const BACKGROUND_COLOR = "#2a2a5a"; // Set via CSS now, but can use for clearRect if needed

    const COLORS = { /* Using slightly softer/cuter colors */
        "pink": "rgb(255, 150, 200)",
        "sky": "rgb(135, 206, 250)",
        "mint": "rgb(150, 255, 180)",
        "lavender": "rgb(200, 160, 255)",
        "peach": "rgb(255, 200, 150)",
        "lemon": "rgb(255, 250, 150)",
    };
    const COLOR_NAMES = Object.keys(COLORS);

    // --- Catcher & Trail ---
    const INITIAL_CATCHER_RADIUS = 20;
    const INITIAL_TRAIL_WIDTH = INITIAL_CATCHER_RADIUS * 1.8;
    const TRAIL_LENGTH = 35;
    const INITIAL_SMOOTHING = 0.18; // Start slightly slower
    const MIN_SMOOTHING = 0.04; // Minimum responsiveness
    const GROWTH_RATE = 0.018; // How much multiplier increases per catch
    const MAX_CATCHER_MULTIPLIER = 3.5; // Max size increase

    // --- Particles ---
    const PARTICLE_COUNT_FIREWORK = 30; // More particles for fireworks
    const PARTICLE_SPEED_FIREWORK = 4.5;
    const PARTICLE_LIFE_FIREWORK = 65;

    // --- Game Variables ---
    let score = 0;
    let mouseX = SCREEN_WIDTH / 2;
    let mouseY = SCREEN_HEIGHT - INITIAL_CATCHER_RADIUS * 3;
    let catcherX = mouseX;
    let catcherY = mouseY;
    let catcherSizeMultiplier = 1.0; // Starts at normal size
    let currentSmoothing = INITIAL_SMOOTHING; // For catcher movement responsiveness
    let trailPoints = [];
    let glowdrops = [];
    let particles = [];
    let stars = [];
    let lastSpawnTime = 0;
    let gameTime = 0;

    // --- Setup ---
    function initializeStars() {
        stars = [];
        const starCount = Math.floor((SCREEN_WIDTH * SCREEN_HEIGHT) / 8000); // Adjust density based on area
        for (let i = 0; i < starCount; i++) {
            stars.push({
                x: Math.random() * SCREEN_WIDTH,
                y: Math.random() * SCREEN_HEIGHT,
                radius: Math.random() * 1.5 + 0.5,
                alpha: Math.random() * 0.5 + 0.3
            });
        }
    }

    function createGlowdrop() {
        const colorName = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
        return {
            id: Date.now() + Math.random(),
            x: Math.random() * (SCREEN_WIDTH - GLOWDROP_RADIUS * 2) + GLOWDROP_RADIUS,
            y: -GLOWDROP_RADIUS * 2,
            radius: GLOWDROP_RADIUS * (Math.random() * 0.2 + 0.9),
            colorName: colorName,
            colorRgb: COLORS[colorName],
            speed: Math.random() * (GLOWDROP_SPEED_MAX - GLOWDROP_SPEED_MIN) + GLOWDROP_SPEED_MIN,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.04
        };
    }

    function createFireworks(x, y, baseColor) {
        const hue = Math.random() * 360;
        for (let i = 0; i < PARTICLE_COUNT_FIREWORK; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * PARTICLE_SPEED_FIREWORK + 1;
            const life = PARTICLE_LIFE_FIREWORK * (Math.random() * 0.5 + 0.5);
            const particleColor = `hsl(${hue + (Math.random() - 0.5) * 60}, 100%, ${Math.random() * 30 + 60}%)`;

            particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed * (Math.random() * 0.5 + 0.5),
                vy: Math.sin(angle) * speed * (Math.random() * 0.5 + 0.5) - 0.5,
                life: life, maxLife: life, color: particleColor,
                radius: Math.random() * 3 + 2,
                gravity: 0.04, // Slightly stronger gravity
                fades: true
            });
        }
    }

    function lerp(start, end, amount) {
        return start + (end - start) * amount;
    }

    // --- Game Loop ---
    function gameLoop(currentTime) {
        gameTime = currentTime;
        update(currentTime);
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update Function ---
    function update(currentTime) {
        // Calculate current smoothing based on size
        // Make slowdown more pronounced as size increases
        currentSmoothing = Math.max(MIN_SMOOTHING, INITIAL_SMOOTHING / (1 + (catcherSizeMultiplier - 1) * 0.7));

        // Smoothly move catcher towards mouse position
        catcherX = lerp(catcherX, mouseX, currentSmoothing);
        catcherY = lerp(catcherY, mouseY, currentSmoothing);

        // Add current catcher position to the trail
        trailPoints.push({ x: catcherX, y: catcherY, time: currentTime });
        while (trailPoints.length > TRAIL_LENGTH) {
            trailPoints.shift();
        }

        // --- Glowdrop Logic ---
        // Spawn
        if (currentTime - lastSpawnTime > GLOWDROP_SPAWN_INTERVAL && glowdrops.length < MAX_GLOWDROPS) {
            glowdrops.push(createGlowdrop());
            lastSpawnTime = currentTime;
        }

        // Move and check collision
        const currentTrailEffectiveWidth = INITIAL_TRAIL_WIDTH * catcherSizeMultiplier; // Width used for collision

        for (let i = glowdrops.length - 1; i >= 0; i--) {
            const drop = glowdrops[i];
            drop.y += drop.speed;
            drop.rotation += drop.rotationSpeed;

            // Collision Check against Trail
            let caught = false;
            for (let j = 0; j < trailPoints.length - 1; j++) {
                const p1 = trailPoints[j];
                // Simple check: distance from drop center to trail point
                const dx = drop.x - p1.x;
                const dy = drop.y - p1.y;
                const distSq = dx * dx + dy * dy;
                const catchRadius = (currentTrailEffectiveWidth / 2) + drop.radius; // Combine radii
                const catchRadiusSq = catchRadius * catchRadius;

                if (distSq < catchRadiusSq) {
                    // --- CATCH ---
                    score += 10;
                    catcherSizeMultiplier = Math.min(MAX_CATCHER_MULTIPLIER, catcherSizeMultiplier + GROWTH_RATE); // Get fatter!
                    console.log(`Caught ${drop.colorName}! Size: ${catcherSizeMultiplier.toFixed(2)}, Smoothing: ${currentSmoothing.toFixed(3)}`);
                    createFireworks(drop.x, drop.y, drop.colorRgb);
                    glowdrops.splice(i, 1);
                    caught = true;
                    break; // Drop caught, move to next drop
                }
            }

            // Remove if off-screen
            if (!caught && drop.y - drop.radius > SCREEN_HEIGHT) {
                glowdrops.splice(i, 1);
            }
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            if (p.gravity) { p.vy += p.gravity; }
            p.life -= 1;
            if (p.life <= 0) { particles.splice(i, 1); }
        }
    }

    // --- Draw Function ---
    function draw() {
        // Clear canvas (or draw background)
        ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); // Clear since bg color is on canvas style

        // Draw stars
        stars.forEach(star => {
            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * (Math.sin(gameTime * 0.0005 + star.x * 0.1) * 0.2 + 0.8)})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        // --- Draw Trail ---
        const baseTrailVisualWidth = INITIAL_TRAIL_WIDTH * catcherSizeMultiplier; // Visual width scales
        if (trailPoints.length > 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let i = 0; i < trailPoints.length - 1; i++) {
                const p1 = trailPoints[i];
                const p2 = trailPoints[i + 1];
                const ratio = i / TRAIL_LENGTH;
                const currentVisualWidth = baseTrailVisualWidth * (0.4 + ratio * 0.6); // Taper width visually
                ctx.lineWidth = currentVisualWidth;
                const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${ratio * 0.4})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${ratio * 0.6 + 0.1})`);
                ctx.strokeStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }

        // --- Draw Catcher ---
        const currentCatcherRadius = INITIAL_CATCHER_RADIUS * catcherSizeMultiplier;
        const catcherPulse = Math.sin(gameTime * 0.01) * 0.08 + 0.92; // Slightly smaller pulse
        const displayRadius = currentCatcherRadius * catcherPulse;
        const catcherGradient = ctx.createRadialGradient(catcherX, catcherY, 0, catcherX, catcherY, displayRadius);
        catcherGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        catcherGradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.9)');
        catcherGradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
        ctx.fillStyle = catcherGradient;
        ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
        ctx.shadowBlur = displayRadius * 0.8; // Adjust shadow with size
        ctx.beginPath();
        ctx.arc(catcherX, catcherY, displayRadius, 0, Math.PI * 2);
        ctx.fill();
        // Star points
        const numPoints = 5 + Math.floor(catcherSizeMultiplier - 1); // More points when bigger
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * Math.PI * 2 + gameTime * 0.002;
            const len = displayRadius * (1.2 + Math.sin(gameTime*0.015 + i)*0.1); // Pulsing length points
            ctx.lineWidth = Math.max(1, 2 * catcherSizeMultiplier * 0.7); // Scale line width, min 1
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(gameTime*0.01 + i*1.5)*0.3})`;
            ctx.beginPath();
            ctx.moveTo(catcherX, catcherY);
            ctx.lineTo(catcherX + Math.cos(angle) * len, catcherY + Math.sin(angle) * len);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;


        // Draw Glowdrops
        glowdrops.forEach(drop => {
            ctx.save();
            ctx.translate(drop.x, drop.y);
            ctx.rotate(drop.rotation);
            const radius = drop.radius;
            const gradient = ctx.createRadialGradient(0, 0, radius * 0.1, 0, 0, radius);
            const baseColor = drop.colorRgb;
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) { /* ... gradient code unchanged ... */
                const [_, r, g, b] = match;
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.9)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.5)`);
            } else { gradient.addColorStop(0, baseColor); gradient.addColorStop(1, baseColor); }
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.shadowColor = drop.colorRgb;
            ctx.shadowBlur = 8; // Slightly smaller blur
            ctx.fill();
            ctx.restore();
        });
        ctx.shadowBlur = 0;

        // Draw Particles (Fireworks)
        particles.forEach(p => { /* ... particle drawing unchanged ... */
            const alpha = p.life / p.maxLife;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
            if (p.color.startsWith('hsl')) {
                // Correct HSL fading: fade lightness or saturation AND alpha
                const match = p.color.match(/hsl\((\d+\.?\d*),\s*(\d+)%,\s*(\d+)%\)/);
                if (match) {
                    const [_, h, s, l] = match;
                    // Fade lightness towards middle gray and fade alpha
                    const fadedL = parseFloat(l) * alpha + 50 * (1 - alpha);
                    ctx.fillStyle = `hsla(${h}, ${s}%, ${fadedL}%, ${alpha})`;
                } else { ctx.fillStyle = p.color;} // Fallback

            } else { // RGB fallback
                const match = p.color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) { ctx.fillStyle = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${p.fades ? alpha : 1})`; }
                else { ctx.fillStyle = p.color; }
            }
            ctx.fill();
        });

        // Score Display
        scoreDisplay.textContent = `Score: ${score}`;
    }

    // --- Event Listeners ---
    canvas.addEventListener('mousemove', function(event) {
        // No clientRect needed if canvas covers whole window and has no border/padding affecting coords
        mouseX = event.clientX;
        mouseY = event.clientY;
    });

    canvas.addEventListener('mouseleave', function(event) {
        // Keep following towards the last known mouse position
    });

    // --- Start ---
    initializeStars();
    requestAnimationFrame(gameLoop); // Start the loop!

</script>

</body>
</html>