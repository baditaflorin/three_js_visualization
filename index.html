<!DOCTYPE html>
<html>
<head>
    <title>Glowdrop Trail Catcher</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a3a; /* Slightly different dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif; /* Cuter font */
            color: white;
        }
        canvas {
            border: 1px solid #444;
            background-color: #2a2a5a; /* Canvas background */
            cursor: none; /* Hide the default mouse cursor */
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 28px;
            z-index: 10;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>

<div id="info">Score: 0</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('info');

    // --- Game Constants ---
    const SCREEN_WIDTH = canvas.width;
    const SCREEN_HEIGHT = canvas.height;
    const GLOWDROP_RADIUS = 14;
    const GLOWDROP_SPEED_MIN = 1.2;
    const GLOWDROP_SPEED_MAX = 3.5;
    const GLOWDROP_SPAWN_INTERVAL = 800;
    const MAX_GLOWDROPS = 25;
    const BACKGROUND_COLOR = "#2a2a5a";

    const COLORS = { /* Using slightly softer/cuter colors */
        "pink": "rgb(255, 150, 200)",
        "sky": "rgb(135, 206, 250)",
        "mint": "rgb(150, 255, 180)",
        "lavender": "rgb(200, 160, 255)",
        "peach": "rgb(255, 200, 150)",
        "lemon": "rgb(255, 250, 150)",
    };
    const COLOR_NAMES = Object.keys(COLORS);

    // --- Catcher & Trail Constants ---
    const CATCHER_RADIUS = 20;
    const TRAIL_LENGTH = 35; // How many points make up the trail
    const TRAIL_WIDTH = CATCHER_RADIUS * 1.8; // How wide the catchable trail area is
    const CATCHER_SMOOTHING = 0.15; // Lower value = smoother/lazier following

    // --- Particle Constants ---
    const PARTICLE_COUNT_FIREWORK = 25;
    const PARTICLE_SPEED_FIREWORK = 4;
    const PARTICLE_LIFE_FIREWORK = 60; // Longer life for fireworks

    // --- Game Variables ---
    let score = 0;
    let mouseX = SCREEN_WIDTH / 2;
    let mouseY = SCREEN_HEIGHT - CATCHER_RADIUS * 3; // Start near bottom
    let catcherX = mouseX;
    let catcherY = mouseY;
    let trailPoints = []; // Stores {x, y, time}
    let glowdrops = [];
    let particles = [];
    let stars = [];
    let lastSpawnTime = 0;
    let gameTime = 0;

    // --- Setup ---
    function initializeStars() {
        stars = [];
        for (let i = 0; i < 150; i++) {
            stars.push({
                x: Math.random() * SCREEN_WIDTH,
                y: Math.random() * SCREEN_HEIGHT,
                radius: Math.random() * 1.5 + 0.5,
                alpha: Math.random() * 0.5 + 0.3 // Vary star brightness
            });
        }
    }

    function createGlowdrop() {
        const colorName = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
        return {
            id: Date.now() + Math.random(),
            x: Math.random() * (SCREEN_WIDTH - GLOWDROP_RADIUS * 2) + GLOWDROP_RADIUS,
            y: -GLOWDROP_RADIUS * 2,
            radius: GLOWDROP_RADIUS * (Math.random() * 0.2 + 0.9), // Slight size variation
            colorName: colorName,
            colorRgb: COLORS[colorName],
            speed: Math.random() * (GLOWDROP_SPEED_MAX - GLOWDROP_SPEED_MIN) + GLOWDROP_SPEED_MIN,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.04
        };
    }

    // --- Fireworks Particle Creation ---
    function createFireworks(x, y, baseColor) {
        const hue = Math.random() * 360; // Random base hue for variety
        for (let i = 0; i < PARTICLE_COUNT_FIREWORK; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * PARTICLE_SPEED_FIREWORK + 1;
            const life = PARTICLE_LIFE_FIREWORK * (Math.random() * 0.5 + 0.5);
            // Vary color slightly around the base hit color or a random hue
            const particleColor = `hsl(${hue + (Math.random() - 0.5) * 60}, 100%, ${Math.random() * 30 + 60}%)`; // Bright, colorful

            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed * (Math.random() * 0.5 + 0.5), // Add randomness to burst shape
                vy: Math.sin(angle) * speed * (Math.random() * 0.5 + 0.5) - 0.5, // Slight upward bias
                life: life,
                maxLife: life,
                color: particleColor,
                radius: Math.random() * 3 + 2,
                gravity: 0.03, // Add slight gravity to particles
                fades: true
            });
        }
    }

    // --- Linear Interpolation (for smoothing) ---
    function lerp(start, end, amount) {
        return start + (end - start) * amount;
    }

    // --- Game Loop ---
    function gameLoop(currentTime) {
        gameTime = currentTime;
        update(currentTime);
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update Function ---
    function update(currentTime) {
        // Smoothly move catcher towards mouse position
        catcherX = lerp(catcherX, mouseX, CATCHER_SMOOTHING);
        catcherY = lerp(catcherY, mouseY, CATCHER_SMOOTHING);

        // Add current catcher position to the trail
        trailPoints.push({ x: catcherX, y: catcherY, time: currentTime });
        // Remove old points from the trail
        while (trailPoints.length > TRAIL_LENGTH) {
            trailPoints.shift(); // Remove the oldest point from the beginning
        }

        // --- Glowdrop Logic ---
        // Spawn
        if (currentTime - lastSpawnTime > GLOWDROP_SPAWN_INTERVAL && glowdrops.length < MAX_GLOWDROPS) {
            glowdrops.push(createGlowdrop());
            lastSpawnTime = currentTime;
        }

        // Move and check collision
        for (let i = glowdrops.length - 1; i >= 0; i--) {
            const drop = glowdrops[i];
            drop.y += drop.speed;
            drop.rotation += drop.rotationSpeed;

            // Collision Check against Trail
            let caught = false;
            for (let j = 0; j < trailPoints.length - 1; j++) {
                const p1 = trailPoints[j];
                const p2 = trailPoints[j + 1];

                // Simple Bounding Box Check first (optimization)
                if (drop.y + drop.radius < Math.min(p1.y, p2.y) - TRAIL_WIDTH/2 ||
                    drop.y - drop.radius > Math.max(p1.y, p2.y) + TRAIL_WIDTH/2) {
                    continue; // Drop is vertically too far from this trail segment
                }

                // Check distance from drop center to the line segment (p1, p2)
                // A simpler check: distance to each point in the trail
                const dx = drop.x - p1.x;
                const dy = drop.y - p1.y;
                const distSq = dx * dx + dy * dy;
                const effectiveTrailRadiusSq = (TRAIL_WIDTH / 2) * (TRAIL_WIDTH / 2);

                if (distSq < (drop.radius * drop.radius) + effectiveTrailRadiusSq) {
                    console.log(`Caught ${drop.colorName} drop!`);
                    score += 10;
                    createFireworks(drop.x, drop.y, drop.colorRgb); // FIREWORKS!
                    glowdrops.splice(i, 1); // Remove drop
                    caught = true;
                    break; // Stop checking this drop against other trail points
                }
            }

            // Remove if off-screen (and not caught)
            if (!caught && drop.y - drop.radius > SCREEN_HEIGHT) {
                glowdrops.splice(i, 1);
            }
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            if (p.gravity) { // Apply gravity if the particle has it
                p.vy += p.gravity;
            }
            p.life -= 1;
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    // --- Draw Function ---
    function draw() {
        // Background
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Stars
        stars.forEach(star => {
            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * (Math.sin(gameTime * 0.0005 + star.x) * 0.2 + 0.8)})`; // Twinkle effect
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw Trail
        if (trailPoints.length > 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let i = 0; i < trailPoints.length - 1; i++) {
                const p1 = trailPoints[i];
                const p2 = trailPoints[i + 1];
                const ratio = i / TRAIL_LENGTH; // 0 (oldest) to 1 (newest)

                // Make trail wider and brighter near the catcher
                const currentWidth = TRAIL_WIDTH * (0.5 + ratio * 0.5);
                ctx.lineWidth = currentWidth;

                // Gradient along the trail segment for color/alpha fade
                const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${ratio * 0.5})`); // Fades out at the end
                gradient.addColorStop(1, `rgba(255, 255, 255, ${ratio * 0.7 + 0.1})`); // Brighter near catcher
                ctx.strokeStyle = gradient;

                // Add a subtle colored glow based on recent catches? (Future idea)
                // ctx.shadowColor = 'rgba(200, 200, 255, 0.5)';
                // ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Draw Catcher (A cute sparkling orb/star)
        const catcherPulse = Math.sin(gameTime * 0.01) * 0.1 + 0.9; // Pulsing size
        const catcherRadius = CATCHER_RADIUS * catcherPulse;
        const catcherGradient = ctx.createRadialGradient(catcherX, catcherY, 0, catcherX, catcherY, catcherRadius);
        catcherGradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // White center
        catcherGradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.8)'); // Light blueish glow
        catcherGradient.addColorStop(1, 'rgba(150, 200, 255, 0)'); // Fading edge
        ctx.fillStyle = catcherGradient;
        ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(catcherX, catcherY, catcherRadius, 0, Math.PI * 2);
        ctx.fill();
        // Add simple star points?
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2 + gameTime * 0.002; // Slowly rotating points
            const len = catcherRadius * 1.3;
            ctx.lineWidth = 2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 + Math.sin(gameTime*0.01 + i*1.5)*0.4})`; // Twinkle line
            ctx.beginPath();
            ctx.moveTo(catcherX, catcherY);
            ctx.lineTo(catcherX + Math.cos(angle) * len, catcherY + Math.sin(angle) * len);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;


        // Draw Glowdrops (Keep the gradient look)
        glowdrops.forEach(drop => {
            ctx.save(); // Save context state
            ctx.translate(drop.x, drop.y); // Move origin to drop center
            ctx.rotate(drop.rotation); // Rotate

            const radius = drop.radius;
            const gradient = ctx.createRadialGradient(0, 0, radius * 0.1, 0, 0, radius);
            const baseColor = drop.colorRgb;
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                const [_, r, g, b] = match;
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.9)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.5)`); // Softer edge
            } else { gradient.addColorStop(0, baseColor); gradient.addColorStop(1, baseColor); }

            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.shadowColor = drop.colorRgb;
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.restore(); // Restore context state
        });
        ctx.shadowBlur = 0;


        // Draw Particles (Fireworks)
        particles.forEach(p => {
            const alpha = p.life / p.maxLife;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
            // Use HSL color directly if available, otherwise parse/fade RGB
            if (p.color.startsWith('hsl')) {
                ctx.fillStyle = p.color.replace(/(\d+)%\)/, `${alpha * 100}%)`); // Fade alpha in HSL
            } else { // Fallback for RGB
                const match = p.color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) {
                    ctx.fillStyle = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${p.fades ? alpha : 1})`;
                } else { ctx.fillStyle = p.color; }
            }
            ctx.fill();
        });

        // Score Display
        scoreDisplay.textContent = `Score: ${score}`;
    }

    // --- Event Listeners ---
    canvas.addEventListener('mousemove', function(event) {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
    });

    canvas.addEventListener('mouseleave', function(event) {
        // Optional: Maybe have the catcher drift to center or stay at edge?
        // For now, let it stay at last known position.
    });


    // --- Start ---
    initializeStars();
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>